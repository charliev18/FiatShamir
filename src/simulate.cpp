#include <iostream>
#include "prover/setup.h"
#include "prover/prover.h"
#include "verifier/verifier.h"
#include "utils.h"
#include "../lib/cxxopts/cxxopts.hpp"

using namespace std;
using namespace Utils;

struct communication {
	int n;									// P->public: product of two primes generated by A
	int k;									// P->public: number of witnesses prover generated
	vector<int> published;					// P->public: +/- multiplicative inverses of A's witnesses

	int x;									// P->V: +/- R^2 % N
	int y;									// P->V: see README

	vector<bool> toggles;					// V->P: k random booleans
};

struct prover_knowledge {
	vector<int> witnesses;					// k random integers in range 0..n
	int r;									// another random integer in range 2..n
};

struct verifier_knowledge {
	int calc_x;								// The value that the verifier calculates and compares to the x sent by prover
};

struct parameters {
	int p;									// Cryptographically secure prime (see documentation)
	int q;									// Cryptographically secure prime (see documentation)
	int k;									// Number of publishable values to generate
	int t;									// Number of rounds required to verify prover knows the secret
};


void print_startup(const parameters& params) {
	cout << "=================================================================================" << endl;
	cout << "Starting Feige-Fiat-Shamir identification protocol" << endl;
	cout << "Provided parameters (p, q, k, t) : (" << params.p << ", " << params.q << ", " << params.k << ", " << params.t << ")" << endl;
	cout << "Probability of successful cheating : 2^(-kt) = " << pow(2, -params.k * params.t) << endl;
	cout << "=================================================================================" << endl;
}

void print_iter_info(const communication& comm, const prover_knowledge& pk, const verifier_knowledge& vk, bool match) {
	Utils::print_prover_step_1(pk.r, comm.x);
	Utils::print_verifier_step_1(comm.toggles);
	Utils::print_prover_step_2(comm.y);
	Utils::print_verifier_step_2(vk.calc_x, match);
}

bool simulate_full_protocol(const parameters& params) {
	communication comm = {};
	prover_knowledge pk = {};
	verifier_knowledge vk = {};

	print_startup(params);

	setup instance = setup(params.p, params.q, params.k);
	instance.choose_witnesses();

	// PROVER PUBLISHES VALUES
	comm.n = instance.n;
	comm.k = instance.k;
	comm.published = instance.publishable;

	// PROVER SAVES WITNESSES PRIVATELY
	pk.witnesses = instance.witnesses;

	Utils::print_after_setup(comm.n, pk.witnesses, comm.published);

	// CREATES PROVER AND VERIFIER FROM SETUP VALUES
	prover prove = prover(comm.k, comm.n, pk.witnesses);
	verifier verif = verifier(comm.k, comm.n);

	bool accepts = true;
	// RUNS THE COMMUNICATION T TIMES
	for (int i = 0; i < params.t; i++) {
		cout << "========================================" << endl;
		cout << "Iteration: " << i + 1 << endl;

		// PROVER CALCULATES THEIR X AND SENDS TO VERIFIER
		comm.x = prove.calculate_x();
		verif.set_x(comm.x);
		pk.r = prove.r;

		// VERIFIER GENERATES RANDOM BOOLEANS
		verif.generate_random_bools();
		comm.toggles = verif.challenge;

		// PROVER CALCULATES Y FROM THEIR PRIVATE VALUES AND VERIFIERS RANDOM BOOLEANS, SENDS Y TO VERIFIER
		comm.y = prove.calculate_y(comm.toggles);

		// VERIFIER CALCULATES X FROM Y AND CONFIRMS IT MATCHES THE ORIGINAL X VALUE
		bool match = verif.verify(comm.y, comm.published);
		accepts &= match;
		vk.calc_x = verif.calc_x;

		print_iter_info(comm, pk, vk, match);
	}

	return accepts;
}

/* Parses the command line input to populate parameters */
parameters parse(int argc, char** argv) {
	cxxopts::Options options("FiatShamirSimulator", "Simulates Fiat Shamir identification protocol");

	options.add_options()
			("p", "First safe prime", cxxopts::value<int>()->default_value(std::to_string(DEFAULT_P)))
			("q", "Second safe prime", cxxopts::value<int>()->default_value(std::to_string(DEFAULT_Q)))
			("k", "Number of witnesses", cxxopts::value<int>()->default_value(std::to_string(DEFAULT_K)))
			("t", "Number of rounds to run", cxxopts::value<int>()->default_value(std::to_string(DEFAULT_T)))
			("h,help", "Print usage");

	auto result = options.parse(argc, argv);

	if (result.count("help")) {
		std::cout << options.help() << std::endl;
		exit(0);
	}

	parameters params = {result["p"].as<int>(),
						 result["q"].as<int>(),
						 result["k"].as<int>(),
						 result["t"].as<int>()};

	return params;
}

int main(int argc, char** argv) {
	// Parse command line input
	parameters params = parse(argc, argv);

	bool accepts = simulate_full_protocol(params);
	if (accepts) {
		cout << "Prover has successfully proven their identity" << endl;
	} else {
		cout << "Prover's proof of identity has been rejected" << endl;
	}
	return 0;
}
